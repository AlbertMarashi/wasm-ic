/// WASM instruction decoder.
///
/// Pure combinational module that translates a WASM opcode byte into control
/// signals for the ALU, operand stack, and execute unit. No clock or state --
/// outputs are valid immediately given an input opcode.
///
/// Supported instruction categories:
///   - Control: unreachable (trap), nop, return
///   - Stack: drop, i32.const
///   - i32 ALU: all 29 arithmetic/logic/comparison/unary operations
///
/// Unsupported opcodes decode as trap (o_trap = 1). As more modules are added
/// (control flow, memory, function calls), this decoder will be extended with
/// additional output signals and opcode mappings.
module WasmDecode (
    i_opcode: input logic<8>, /// Raw WASM opcode byte

    // ALU control
    o_alu_op: output WasmAluPkg::AluOp, /// ALU operation select
    o_alu_en: output logic            , /// 1 = ALU should execute this cycle

    // Stack control
    o_push: output logic, /// Push a value onto the operand stack
    o_pop : output logic, /// Pop 1 value from the operand stack
    o_pop2: output logic, /// Pop 2 values from the operand stack

    // Instruction type signals
    o_is_const : output logic, /// i32.const -- fetch unit provides the immediate
    o_is_return: output logic, /// return instruction
    o_trap     : output logic, /// Trap: unreachable or invalid opcode
) {
    import WasmAluPkg::*;

    always_comb {
        // Defaults: everything off
        o_alu_op    = AluOp::Add;
        o_alu_en    = 0;
        o_push      = 0;
        o_pop       = 0;
        o_pop2      = 0;
        o_is_const  = 0;
        o_is_return = 0;
        o_trap      = 0;

        case i_opcode {
            // -------------------------------------------------------
            // Control
            // -------------------------------------------------------
            8'h00: { // unreachable
                o_trap = 1;
            }
            8'h01: {} // nop -- all outputs stay 0
            8'h0F: { // return
                o_is_return = 1;
            }

            // -------------------------------------------------------
            // Stack manipulation
            // -------------------------------------------------------
            8'h1A: { // drop
                o_pop = 1;
            }
            8'h41: { // i32.const (immediate follows in bytecode)
                o_is_const = 1;
                o_push     = 1;
            }

            // -------------------------------------------------------
            // i32 comparison (unary)
            // -------------------------------------------------------
            8'h45: { // i32.eqz
                o_alu_en = 1;
                o_alu_op = AluOp::Eqz;
                o_pop    = 1;
                o_push   = 1;
            }

            // -------------------------------------------------------
            // i32 comparison (binary)
            // -------------------------------------------------------
            8'h46: {
                o_alu_en = 1;
                o_alu_op = AluOp::Eq;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.eq
            8'h47: {
                o_alu_en = 1;
                o_alu_op = AluOp::Ne;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.ne
            8'h48: {
                o_alu_en = 1;
                o_alu_op = AluOp::LtS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.lt_s
            8'h49: {
                o_alu_en = 1;
                o_alu_op = AluOp::LtU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.lt_u
            8'h4A: {
                o_alu_en = 1;
                o_alu_op = AluOp::GtS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.gt_s
            8'h4B: {
                o_alu_en = 1;
                o_alu_op = AluOp::GtU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.gt_u
            8'h4C: {
                o_alu_en = 1;
                o_alu_op = AluOp::LeS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.le_s
            8'h4D: {
                o_alu_en = 1;
                o_alu_op = AluOp::LeU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.le_u
            8'h4E: {
                o_alu_en = 1;
                o_alu_op = AluOp::GeS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.ge_s
            8'h4F: {
                o_alu_en = 1;
                o_alu_op = AluOp::GeU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.ge_u

            // -------------------------------------------------------
            // i32 unary
            // -------------------------------------------------------
            8'h67: {
                o_alu_en = 1;
                o_alu_op = AluOp::Clz;
                o_pop    = 1;
                o_push   = 1;
            } // i32.clz
            8'h68: {
                o_alu_en = 1;
                o_alu_op = AluOp::Ctz;
                o_pop    = 1;
                o_push   = 1;
            } // i32.ctz
            8'h69: {
                o_alu_en = 1;
                o_alu_op = AluOp::Popcnt;
                o_pop    = 1;
                o_push   = 1;
            } // i32.popcnt

            // -------------------------------------------------------
            // i32 arithmetic
            // -------------------------------------------------------
            8'h6A: {
                o_alu_en = 1;
                o_alu_op = AluOp::Add;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.add
            8'h6B: {
                o_alu_en = 1;
                o_alu_op = AluOp::Sub;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.sub
            8'h6C: {
                o_alu_en = 1;
                o_alu_op = AluOp::Mul;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.mul
            8'h6D: {
                o_alu_en = 1;
                o_alu_op = AluOp::DivS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.div_s
            8'h6E: {
                o_alu_en = 1;
                o_alu_op = AluOp::DivU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.div_u
            8'h6F: {
                o_alu_en = 1;
                o_alu_op = AluOp::RemS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rem_s
            8'h70: {
                o_alu_en = 1;
                o_alu_op = AluOp::RemU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rem_u

            // -------------------------------------------------------
            // i32 bitwise
            // -------------------------------------------------------
            8'h71: {
                o_alu_en = 1;
                o_alu_op = AluOp::And;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.and
            8'h72: {
                o_alu_en = 1;
                o_alu_op = AluOp::Or;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.or
            8'h73: {
                o_alu_en = 1;
                o_alu_op = AluOp::Xor;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.xor

            // -------------------------------------------------------
            // i32 shifts & rotates
            // -------------------------------------------------------
            8'h74: {
                o_alu_en = 1;
                o_alu_op = AluOp::Shl;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.shl
            8'h75: {
                o_alu_en = 1;
                o_alu_op = AluOp::ShrS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.shr_s
            8'h76: {
                o_alu_en = 1;
                o_alu_op = AluOp::ShrU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.shr_u
            8'h77: {
                o_alu_en = 1;
                o_alu_op = AluOp::Rotl;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rotl
            8'h78: {
                o_alu_en = 1;
                o_alu_op = AluOp::Rotr;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rotr

            // -------------------------------------------------------
            // Invalid / unsupported opcode
            // -------------------------------------------------------
            default: {
                o_trap = 1;
            }
        }
    }
}

// ---------------------------------------------------------------------------
// Testbench -- verifies all 34 supported opcodes and invalid opcode handling.
// Run with: veryl test --sim verilator
// ---------------------------------------------------------------------------
#[test(test_wasm_decode)]
embed (inline) sv{{{
module test_wasm_decode;
    import hello_WasmAluPkg::*;

    logic [7:0] opcode;
    AluOp       alu_op;
    logic       alu_en, push, pop, pop2, is_const, is_return, trap;
    int         pass_count, fail_count;

    hello_WasmDecode u_dec (
        .i_opcode    (opcode   ),
        .o_alu_op    (alu_op   ),
        .o_alu_en    (alu_en   ),
        .o_push      (push     ),
        .o_pop       (pop      ),
        .o_pop2      (pop2     ),
        .o_is_const  (is_const ),
        .o_is_return (is_return),
        .o_trap      (trap     )
    );

    // Check a binary ALU op: expects alu_en=1, pop2=1, push=1, specific alu_op
    task check_binary(input string name, input [7:0] opc, input AluOp exp_op);
        opcode = opc;
        #1;
        if (alu_en !== 1 || pop2 !== 1 || push !== 1 || pop !== 0 ||
            alu_op !== exp_op || trap !== 0 || is_const !== 0 || is_return !== 0) begin
            $error("%s (0x%02h): alu_en=%0b pop2=%0b push=%0b alu_op=%0d | expected binary ALU op %0d",
                   name, opc, alu_en, pop2, push, alu_op, exp_op);
            fail_count++;
        end else begin
            pass_count++;
        end
    endtask

    // Check a unary ALU op: expects alu_en=1, pop=1, push=1, specific alu_op
    task check_unary(input string name, input [7:0] opc, input AluOp exp_op);
        opcode = opc;
        #1;
        if (alu_en !== 1 || pop !== 1 || push !== 1 || pop2 !== 0 ||
            alu_op !== exp_op || trap !== 0 || is_const !== 0 || is_return !== 0) begin
            $error("%s (0x%02h): alu_en=%0b pop=%0b push=%0b alu_op=%0d | expected unary ALU op %0d",
                   name, opc, alu_en, pop, push, alu_op, exp_op);
            fail_count++;
        end else begin
            pass_count++;
        end
    endtask

    initial begin
        pass_count = 0;
        fail_count = 0;

        // --- Control instructions ---

        // unreachable -> trap
        opcode = 8'h00; #1;
        if (trap !== 1 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0) begin
            $error("unreachable: expected trap=1, all else 0");
            fail_count++;
        end else pass_count++;

        // nop -> everything 0
        opcode = 8'h01; #1;
        if (trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0 ||
            is_const !== 0 || is_return !== 0) begin
            $error("nop: expected all outputs 0");
            fail_count++;
        end else pass_count++;

        // return
        opcode = 8'h0F; #1;
        if (is_return !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0) begin
            $error("return: expected is_return=1 only");
            fail_count++;
        end else pass_count++;

        // --- Stack manipulation ---

        // drop -> pop only
        opcode = 8'h1A; #1;
        if (pop !== 1 || push !== 0 || pop2 !== 0 || alu_en !== 0 || trap !== 0) begin
            $error("drop: expected pop=1 only");
            fail_count++;
        end else pass_count++;

        // i32.const -> is_const + push
        opcode = 8'h41; #1;
        if (is_const !== 1 || push !== 1 || alu_en !== 0 || pop !== 0 || pop2 !== 0 || trap !== 0) begin
            $error("i32.const: expected is_const=1, push=1");
            fail_count++;
        end else pass_count++;

        // --- Unary ALU ops ---
        check_unary("i32.eqz",    8'h45, AluOp_Eqz);
        check_unary("i32.clz",    8'h67, AluOp_Clz);
        check_unary("i32.ctz",    8'h68, AluOp_Ctz);
        check_unary("i32.popcnt", 8'h69, AluOp_Popcnt);

        // --- Binary comparison ops ---
        check_binary("i32.eq",   8'h46, AluOp_Eq);
        check_binary("i32.ne",   8'h47, AluOp_Ne);
        check_binary("i32.lt_s", 8'h48, AluOp_LtS);
        check_binary("i32.lt_u", 8'h49, AluOp_LtU);
        check_binary("i32.gt_s", 8'h4A, AluOp_GtS);
        check_binary("i32.gt_u", 8'h4B, AluOp_GtU);
        check_binary("i32.le_s", 8'h4C, AluOp_LeS);
        check_binary("i32.le_u", 8'h4D, AluOp_LeU);
        check_binary("i32.ge_s", 8'h4E, AluOp_GeS);
        check_binary("i32.ge_u", 8'h4F, AluOp_GeU);

        // --- Binary arithmetic ops ---
        check_binary("i32.add",   8'h6A, AluOp_Add);
        check_binary("i32.sub",   8'h6B, AluOp_Sub);
        check_binary("i32.mul",   8'h6C, AluOp_Mul);
        check_binary("i32.div_s", 8'h6D, AluOp_DivS);
        check_binary("i32.div_u", 8'h6E, AluOp_DivU);
        check_binary("i32.rem_s", 8'h6F, AluOp_RemS);
        check_binary("i32.rem_u", 8'h70, AluOp_RemU);

        // --- Binary bitwise ops ---
        check_binary("i32.and", 8'h71, AluOp_And);
        check_binary("i32.or",  8'h72, AluOp_Or);
        check_binary("i32.xor", 8'h73, AluOp_Xor);

        // --- Binary shift/rotate ops ---
        check_binary("i32.shl",   8'h74, AluOp_Shl);
        check_binary("i32.shr_s", 8'h75, AluOp_ShrS);
        check_binary("i32.shr_u", 8'h76, AluOp_ShrU);
        check_binary("i32.rotl",  8'h77, AluOp_Rotl);
        check_binary("i32.rotr",  8'h78, AluOp_Rotr);

        // --- Invalid opcodes -> trap ---
        opcode = 8'h02; #1; // block (unsupported)
        if (trap !== 1) begin $error("0x02 should trap"); fail_count++; end else pass_count++;

        opcode = 8'hFF; #1;
        if (trap !== 1) begin $error("0xFF should trap"); fail_count++; end else pass_count++;

        opcode = 8'h42; #1; // i64.const (unsupported)
        if (trap !== 1) begin $error("0x42 should trap"); fail_count++; end else pass_count++;

        $display("=== WASM Decode Test Complete: %0d passed, %0d failed ===", pass_count, fail_count);
        if (fail_count > 0)
            $error("FAIL: %0d tests failed", fail_count);
        $finish;
    end
endmodule
}}}
