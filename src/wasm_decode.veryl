/// WASM instruction decoder.
///
/// Pure combinational module that translates a WASM opcode byte into control
/// signals for the ALU, operand stack, and execute unit. No clock or state --
/// outputs are valid immediately given an input opcode.
///
/// Supported instruction categories:
///   - Control: unreachable (trap), nop, return
///   - Control flow: block, loop, if, else, end, br, br_if
///   - Stack: drop, i32.const
///   - i32 ALU: all 29 arithmetic/logic/comparison/unary operations
///
/// Unsupported opcodes decode as trap (o_trap = 1). As more modules are added
/// (memory, function calls), this decoder will be extended with additional
/// output signals and opcode mappings.
module WasmDecode (
    i_opcode: input logic<8>, /// Raw WASM opcode byte

    // ALU control
    o_alu_op: output WasmAluPkg::AluOp, /// ALU operation select
    o_alu_en: output logic            , /// 1 = ALU should execute this cycle

    // Stack control
    o_push: output logic, /// Push a value onto the operand stack
    o_pop : output logic, /// Pop 1 value from the operand stack
    o_pop2: output logic, /// Pop 2 values from the operand stack

    // Instruction type signals
    o_is_const : output logic, /// i32.const -- fetch unit provides the immediate
    o_is_return: output logic, /// return instruction
    o_trap     : output logic, /// Trap: unreachable or invalid opcode

    // Control flow signals
    o_is_block: output logic, /// block or loop -- has block type immediate to skip
    o_is_if   : output logic, /// if -- conditional block, has block type immediate
    o_is_else : output logic, /// else -- unconditional jump to end
    o_is_end  : output logic, /// end -- close current block
    o_is_br   : output logic, /// br -- unconditional branch, has LEB128 immediate
    o_is_br_if: output logic, /// br_if -- conditional branch, has LEB128 immediate

    // Memory signals
    o_is_load   : output logic   , /// load instruction (i32.load, i32.load8_s, etc.)
    o_is_store  : output logic   , /// store instruction (i32.store, i32.store8, etc.)
    o_mem_size  : output logic<2>, /// 0=byte, 1=halfword, 2=word
    o_mem_signed: output logic   , /// 1=sign-extend load, 0=zero-extend
) {
    import WasmAluPkg::*;

    always_comb {
        // Defaults: everything off
        o_alu_op     = AluOp::Add;
        o_alu_en     = 0;
        o_push       = 0;
        o_pop        = 0;
        o_pop2       = 0;
        o_is_const   = 0;
        o_is_return  = 0;
        o_trap       = 0;
        o_is_block   = 0;
        o_is_if      = 0;
        o_is_else    = 0;
        o_is_end     = 0;
        o_is_br      = 0;
        o_is_br_if   = 0;
        o_is_load    = 0;
        o_is_store   = 0;
        o_mem_size   = 0;
        o_mem_signed = 0;

        case i_opcode {
            // -------------------------------------------------------
            // Control
            // -------------------------------------------------------
            8'h00: { // unreachable
                o_trap = 1;
            }
            8'h01: {} // nop -- all outputs stay 0
            8'h02: { // block (block type byte follows)
                o_is_block = 1;
            }
            8'h03: { // loop (block type byte follows)
                o_is_block = 1;
            }
            8'h04: { // if (pops condition from stack, block type byte follows)
                o_is_if = 1;
                o_pop   = 1;
            }
            8'h05: { // else (unconditional jump to end)
                o_is_else = 1;
            }
            8'h0B: { // end (close current block)
                o_is_end = 1;
            }
            8'h0C: { // br (LEB128 depth follows)
                o_is_br = 1;
            }
            8'h0D: { // br_if (pops condition, LEB128 depth follows)
                o_is_br_if = 1;
                o_pop      = 1;
            }
            8'h0F: { // return
                o_is_return = 1;
            }

            // -------------------------------------------------------
            // Stack manipulation
            // -------------------------------------------------------
            8'h1A: { // drop
                o_pop = 1;
            }
            8'h41: { // i32.const (immediate follows in bytecode)
                o_is_const = 1;
                o_push     = 1;
            }

            // -------------------------------------------------------
            // Memory load
            // -------------------------------------------------------
            8'h28: { // i32.load
                o_is_load  = 1;
                o_mem_size = 2'd2;
                o_pop      = 1;
                o_push     = 1;
            }
            8'h2C: { // i32.load8_s
                o_is_load    = 1;
                o_mem_size   = 2'd0;
                o_mem_signed = 1;
                o_pop        = 1;
                o_push       = 1;
            }
            8'h2D: { // i32.load8_u
                o_is_load  = 1;
                o_mem_size = 2'd0;
                o_pop      = 1;
                o_push     = 1;
            }
            8'h2E: { // i32.load16_s
                o_is_load    = 1;
                o_mem_size   = 2'd1;
                o_mem_signed = 1;
                o_pop        = 1;
                o_push       = 1;
            }
            8'h2F: { // i32.load16_u
                o_is_load  = 1;
                o_mem_size = 2'd1;
                o_pop      = 1;
                o_push     = 1;
            }

            // -------------------------------------------------------
            // Memory store
            // -------------------------------------------------------
            8'h36: { // i32.store
                o_is_store = 1;
                o_mem_size = 2'd2;
                o_pop2     = 1;
            }
            8'h3A: { // i32.store8
                o_is_store = 1;
                o_mem_size = 2'd0;
                o_pop2     = 1;
            }
            8'h3B: { // i32.store16
                o_is_store = 1;
                o_mem_size = 2'd1;
                o_pop2     = 1;
            }

            // -------------------------------------------------------
            // i32 comparison (unary)
            // -------------------------------------------------------
            8'h45: { // i32.eqz
                o_alu_en = 1;
                o_alu_op = AluOp::Eqz;
                o_pop    = 1;
                o_push   = 1;
            }

            // -------------------------------------------------------
            // i32 comparison (binary)
            // -------------------------------------------------------
            8'h46: {
                o_alu_en = 1;
                o_alu_op = AluOp::Eq;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.eq
            8'h47: {
                o_alu_en = 1;
                o_alu_op = AluOp::Ne;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.ne
            8'h48: {
                o_alu_en = 1;
                o_alu_op = AluOp::LtS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.lt_s
            8'h49: {
                o_alu_en = 1;
                o_alu_op = AluOp::LtU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.lt_u
            8'h4A: {
                o_alu_en = 1;
                o_alu_op = AluOp::GtS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.gt_s
            8'h4B: {
                o_alu_en = 1;
                o_alu_op = AluOp::GtU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.gt_u
            8'h4C: {
                o_alu_en = 1;
                o_alu_op = AluOp::LeS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.le_s
            8'h4D: {
                o_alu_en = 1;
                o_alu_op = AluOp::LeU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.le_u
            8'h4E: {
                o_alu_en = 1;
                o_alu_op = AluOp::GeS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.ge_s
            8'h4F: {
                o_alu_en = 1;
                o_alu_op = AluOp::GeU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.ge_u

            // -------------------------------------------------------
            // i32 unary
            // -------------------------------------------------------
            8'h67: {
                o_alu_en = 1;
                o_alu_op = AluOp::Clz;
                o_pop    = 1;
                o_push   = 1;
            } // i32.clz
            8'h68: {
                o_alu_en = 1;
                o_alu_op = AluOp::Ctz;
                o_pop    = 1;
                o_push   = 1;
            } // i32.ctz
            8'h69: {
                o_alu_en = 1;
                o_alu_op = AluOp::Popcnt;
                o_pop    = 1;
                o_push   = 1;
            } // i32.popcnt

            // -------------------------------------------------------
            // i32 arithmetic
            // -------------------------------------------------------
            8'h6A: {
                o_alu_en = 1;
                o_alu_op = AluOp::Add;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.add
            8'h6B: {
                o_alu_en = 1;
                o_alu_op = AluOp::Sub;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.sub
            8'h6C: {
                o_alu_en = 1;
                o_alu_op = AluOp::Mul;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.mul
            8'h6D: {
                o_alu_en = 1;
                o_alu_op = AluOp::DivS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.div_s
            8'h6E: {
                o_alu_en = 1;
                o_alu_op = AluOp::DivU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.div_u
            8'h6F: {
                o_alu_en = 1;
                o_alu_op = AluOp::RemS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rem_s
            8'h70: {
                o_alu_en = 1;
                o_alu_op = AluOp::RemU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rem_u

            // -------------------------------------------------------
            // i32 bitwise
            // -------------------------------------------------------
            8'h71: {
                o_alu_en = 1;
                o_alu_op = AluOp::And;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.and
            8'h72: {
                o_alu_en = 1;
                o_alu_op = AluOp::Or;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.or
            8'h73: {
                o_alu_en = 1;
                o_alu_op = AluOp::Xor;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.xor

            // -------------------------------------------------------
            // i32 shifts & rotates
            // -------------------------------------------------------
            8'h74: {
                o_alu_en = 1;
                o_alu_op = AluOp::Shl;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.shl
            8'h75: {
                o_alu_en = 1;
                o_alu_op = AluOp::ShrS;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.shr_s
            8'h76: {
                o_alu_en = 1;
                o_alu_op = AluOp::ShrU;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.shr_u
            8'h77: {
                o_alu_en = 1;
                o_alu_op = AluOp::Rotl;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rotl
            8'h78: {
                o_alu_en = 1;
                o_alu_op = AluOp::Rotr;
                o_pop2   = 1;
                o_push   = 1;
            } // i32.rotr

            // -------------------------------------------------------
            // Invalid / unsupported opcode
            // -------------------------------------------------------
            default: {
                o_trap = 1;
            }
        }
    }
}

// ---------------------------------------------------------------------------
// Testbench -- verifies all 34 supported opcodes and invalid opcode handling.
// Run with: veryl test --sim verilator
// ---------------------------------------------------------------------------
#[test(test_wasm_decode)]
embed (inline) sv{{{
module test_wasm_decode;
    import hello_WasmAluPkg::*;

    logic [7:0] opcode;
    AluOp       alu_op;
    logic       alu_en, push, pop, pop2, is_const, is_return, trap;
    logic       is_block, is_if, is_else, is_end, is_br, is_br_if;
    logic       is_load, is_store, mem_signed;
    logic [1:0] mem_size;
    int         pass_count, fail_count;

    hello_WasmDecode u_dec (
        .i_opcode     (opcode    ),
        .o_alu_op     (alu_op    ),
        .o_alu_en     (alu_en    ),
        .o_push       (push      ),
        .o_pop        (pop       ),
        .o_pop2       (pop2      ),
        .o_is_const   (is_const  ),
        .o_is_return  (is_return ),
        .o_trap       (trap      ),
        .o_is_block   (is_block  ),
        .o_is_if      (is_if     ),
        .o_is_else    (is_else   ),
        .o_is_end     (is_end    ),
        .o_is_br      (is_br     ),
        .o_is_br_if   (is_br_if  ),
        .o_is_load    (is_load   ),
        .o_is_store   (is_store  ),
        .o_mem_size   (mem_size  ),
        .o_mem_signed (mem_signed)
    );

    // Check a binary ALU op: expects alu_en=1, pop2=1, push=1, specific alu_op
    task check_binary(input string name, input [7:0] opc, input AluOp exp_op);
        opcode = opc;
        #1;
        if (alu_en !== 1 || pop2 !== 1 || push !== 1 || pop !== 0 ||
            alu_op !== exp_op || trap !== 0 || is_const !== 0 || is_return !== 0) begin
            $error("%s (0x%02h): alu_en=%0b pop2=%0b push=%0b alu_op=%0d | expected binary ALU op %0d",
                   name, opc, alu_en, pop2, push, alu_op, exp_op);
            fail_count++;
        end else begin
            pass_count++;
        end
    endtask

    // Check a unary ALU op: expects alu_en=1, pop=1, push=1, specific alu_op
    task check_unary(input string name, input [7:0] opc, input AluOp exp_op);
        opcode = opc;
        #1;
        if (alu_en !== 1 || pop !== 1 || push !== 1 || pop2 !== 0 ||
            alu_op !== exp_op || trap !== 0 || is_const !== 0 || is_return !== 0) begin
            $error("%s (0x%02h): alu_en=%0b pop=%0b push=%0b alu_op=%0d | expected unary ALU op %0d",
                   name, opc, alu_en, pop, push, alu_op, exp_op);
            fail_count++;
        end else begin
            pass_count++;
        end
    endtask

    initial begin
        pass_count = 0;
        fail_count = 0;

        // --- Control instructions ---

        // unreachable -> trap
        opcode = 8'h00; #1;
        if (trap !== 1 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0) begin
            $error("unreachable: expected trap=1, all else 0");
            fail_count++;
        end else pass_count++;

        // nop -> everything 0
        opcode = 8'h01; #1;
        if (trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0 ||
            is_const !== 0 || is_return !== 0) begin
            $error("nop: expected all outputs 0");
            fail_count++;
        end else pass_count++;

        // return
        opcode = 8'h0F; #1;
        if (is_return !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0) begin
            $error("return: expected is_return=1 only");
            fail_count++;
        end else pass_count++;

        // --- Stack manipulation ---

        // drop -> pop only
        opcode = 8'h1A; #1;
        if (pop !== 1 || push !== 0 || pop2 !== 0 || alu_en !== 0 || trap !== 0) begin
            $error("drop: expected pop=1 only");
            fail_count++;
        end else pass_count++;

        // i32.const -> is_const + push
        opcode = 8'h41; #1;
        if (is_const !== 1 || push !== 1 || alu_en !== 0 || pop !== 0 || pop2 !== 0 || trap !== 0) begin
            $error("i32.const: expected is_const=1, push=1");
            fail_count++;
        end else pass_count++;

        // --- Unary ALU ops ---
        check_unary("i32.eqz",    8'h45, AluOp_Eqz);
        check_unary("i32.clz",    8'h67, AluOp_Clz);
        check_unary("i32.ctz",    8'h68, AluOp_Ctz);
        check_unary("i32.popcnt", 8'h69, AluOp_Popcnt);

        // --- Binary comparison ops ---
        check_binary("i32.eq",   8'h46, AluOp_Eq);
        check_binary("i32.ne",   8'h47, AluOp_Ne);
        check_binary("i32.lt_s", 8'h48, AluOp_LtS);
        check_binary("i32.lt_u", 8'h49, AluOp_LtU);
        check_binary("i32.gt_s", 8'h4A, AluOp_GtS);
        check_binary("i32.gt_u", 8'h4B, AluOp_GtU);
        check_binary("i32.le_s", 8'h4C, AluOp_LeS);
        check_binary("i32.le_u", 8'h4D, AluOp_LeU);
        check_binary("i32.ge_s", 8'h4E, AluOp_GeS);
        check_binary("i32.ge_u", 8'h4F, AluOp_GeU);

        // --- Binary arithmetic ops ---
        check_binary("i32.add",   8'h6A, AluOp_Add);
        check_binary("i32.sub",   8'h6B, AluOp_Sub);
        check_binary("i32.mul",   8'h6C, AluOp_Mul);
        check_binary("i32.div_s", 8'h6D, AluOp_DivS);
        check_binary("i32.div_u", 8'h6E, AluOp_DivU);
        check_binary("i32.rem_s", 8'h6F, AluOp_RemS);
        check_binary("i32.rem_u", 8'h70, AluOp_RemU);

        // --- Binary bitwise ops ---
        check_binary("i32.and", 8'h71, AluOp_And);
        check_binary("i32.or",  8'h72, AluOp_Or);
        check_binary("i32.xor", 8'h73, AluOp_Xor);

        // --- Binary shift/rotate ops ---
        check_binary("i32.shl",   8'h74, AluOp_Shl);
        check_binary("i32.shr_s", 8'h75, AluOp_ShrS);
        check_binary("i32.shr_u", 8'h76, AluOp_ShrU);
        check_binary("i32.rotl",  8'h77, AluOp_Rotl);
        check_binary("i32.rotr",  8'h78, AluOp_Rotr);

        // --- Control flow opcodes ---

        // block (0x02) -> is_block=1, no pop, no push, no trap
        opcode = 8'h02; #1;
        if (is_block !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0) begin
            $error("block: expected is_block=1 only"); fail_count++;
        end else pass_count++;

        // loop (0x03) -> is_block=1
        opcode = 8'h03; #1;
        if (is_block !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0) begin
            $error("loop: expected is_block=1 only"); fail_count++;
        end else pass_count++;

        // if (0x04) -> is_if=1, pop=1 (condition)
        opcode = 8'h04; #1;
        if (is_if !== 1 || pop !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop2 !== 0) begin
            $error("if: expected is_if=1, pop=1"); fail_count++;
        end else pass_count++;

        // else (0x05) -> is_else=1
        opcode = 8'h05; #1;
        if (is_else !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0) begin
            $error("else: expected is_else=1 only"); fail_count++;
        end else pass_count++;

        // end (0x0B) -> is_end=1
        opcode = 8'h0B; #1;
        if (is_end !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0) begin
            $error("end: expected is_end=1 only"); fail_count++;
        end else pass_count++;

        // br (0x0C) -> is_br=1
        opcode = 8'h0C; #1;
        if (is_br !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop !== 0 || pop2 !== 0) begin
            $error("br: expected is_br=1 only"); fail_count++;
        end else pass_count++;

        // br_if (0x0D) -> is_br_if=1, pop=1 (condition)
        opcode = 8'h0D; #1;
        if (is_br_if !== 1 || pop !== 1 || trap !== 0 || alu_en !== 0 || push !== 0 || pop2 !== 0) begin
            $error("br_if: expected is_br_if=1, pop=1"); fail_count++;
        end else pass_count++;

        // --- Memory load opcodes ---

        // i32.load (0x28) -> is_load=1, mem_size=2, pop=1, push=1
        opcode = 8'h28; #1;
        if (is_load !== 1 || mem_size !== 2'd2 || mem_signed !== 0 || pop !== 1 || push !== 1 || trap !== 0) begin
            $error("i32.load: expected is_load=1, mem_size=2, pop=1, push=1"); fail_count++;
        end else pass_count++;

        // i32.load8_s (0x2C) -> is_load=1, mem_size=0, mem_signed=1, pop=1, push=1
        opcode = 8'h2C; #1;
        if (is_load !== 1 || mem_size !== 2'd0 || mem_signed !== 1 || pop !== 1 || push !== 1 || trap !== 0) begin
            $error("i32.load8_s: expected is_load=1, mem_size=0, mem_signed=1"); fail_count++;
        end else pass_count++;

        // i32.load8_u (0x2D) -> is_load=1, mem_size=0, mem_signed=0
        opcode = 8'h2D; #1;
        if (is_load !== 1 || mem_size !== 2'd0 || mem_signed !== 0 || pop !== 1 || push !== 1 || trap !== 0) begin
            $error("i32.load8_u: expected is_load=1, mem_size=0, mem_signed=0"); fail_count++;
        end else pass_count++;

        // i32.load16_s (0x2E)
        opcode = 8'h2E; #1;
        if (is_load !== 1 || mem_size !== 2'd1 || mem_signed !== 1 || pop !== 1 || push !== 1 || trap !== 0) begin
            $error("i32.load16_s: expected is_load=1, mem_size=1, mem_signed=1"); fail_count++;
        end else pass_count++;

        // i32.load16_u (0x2F)
        opcode = 8'h2F; #1;
        if (is_load !== 1 || mem_size !== 2'd1 || mem_signed !== 0 || pop !== 1 || push !== 1 || trap !== 0) begin
            $error("i32.load16_u: expected is_load=1, mem_size=1, mem_signed=0"); fail_count++;
        end else pass_count++;

        // --- Memory store opcodes ---

        // i32.store (0x36) -> is_store=1, mem_size=2, pop2=1
        opcode = 8'h36; #1;
        if (is_store !== 1 || mem_size !== 2'd2 || pop2 !== 1 || push !== 0 || trap !== 0) begin
            $error("i32.store: expected is_store=1, mem_size=2, pop2=1"); fail_count++;
        end else pass_count++;

        // i32.store8 (0x3A) -> is_store=1, mem_size=0, pop2=1
        opcode = 8'h3A; #1;
        if (is_store !== 1 || mem_size !== 2'd0 || pop2 !== 1 || push !== 0 || trap !== 0) begin
            $error("i32.store8: expected is_store=1, mem_size=0, pop2=1"); fail_count++;
        end else pass_count++;

        // i32.store16 (0x3B) -> is_store=1, mem_size=1, pop2=1
        opcode = 8'h3B; #1;
        if (is_store !== 1 || mem_size !== 2'd1 || pop2 !== 1 || push !== 0 || trap !== 0) begin
            $error("i32.store16: expected is_store=1, mem_size=1, pop2=1"); fail_count++;
        end else pass_count++;

        // --- Invalid opcodes -> trap ---
        opcode = 8'hFF; #1;
        if (trap !== 1) begin $error("0xFF should trap"); fail_count++; end else pass_count++;

        opcode = 8'h42; #1; // i64.const (unsupported)
        if (trap !== 1) begin $error("0x42 should trap"); fail_count++; end else pass_count++;

        opcode = 8'h06; #1; // unsupported
        if (trap !== 1) begin $error("0x06 should trap"); fail_count++; end else pass_count++;

        $display("=== WASM Decode Test Complete: %0d passed, %0d failed ===", pass_count, fail_count);
        if (fail_count > 0)
            $error("FAIL: %0d tests failed", fail_count);
        $finish;
    end
endmodule
}}}
